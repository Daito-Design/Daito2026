<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Daito Design - Abstract Ken Burns</title>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;500&family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      overflow: hidden;
      background: #1A1A1A;
      font-family: 'Inter', sans-serif;
    }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>
  <script>
    const canvas = document.getElementById('bg');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;

    let width, height;
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);
    }
    resize();
    window.addEventListener('resize', resize);

    // Daito Design brand colors
    const colors = {
      charcoal: '#1A1A1A',
      charcoalLight: '#2C2C2C',
      sand: '#F5F0E8',
      sandDark: '#E8E0D4',
      sandDarker: '#D4C9B8',
      oxblood: '#722F37',
      oxbloodLight: '#8B3A44',
      oxbloodGlow: 'rgba(114, 47, 55, 0.15)'
    };

    // Ken Burns camera
    const camera = {
      x: 0, y: 0, zoom: 1,
      targetX: 0, targetY: 0, targetZoom: 1,
      time: 0,

      update() {
        this.time += 0.00015; // Very slow, cinematic

        // Gentle drift
        this.targetX = Math.sin(this.time * 0.8) * width * 0.05;
        this.targetY = Math.cos(this.time * 0.6) * height * 0.04;
        this.targetZoom = 1 + Math.sin(this.time * 0.4) * 0.08;

        // Smooth easing
        this.x += (this.targetX - this.x) * 0.001;
        this.y += (this.targetY - this.y) * 0.001;
        this.zoom += (this.targetZoom - this.zoom) * 0.001;
      },

      apply() {
        ctx.translate(width/2, height/2);
        ctx.scale(this.zoom, this.zoom);
        ctx.translate(-width/2 + this.x, -height/2 + this.y);
      }
    };

    // Abstract gradient orbs - very soft, premium
    class GradientOrb {
      constructor(config) {
        this.x = config.x * width;
        this.y = config.y * height;
        this.size = config.size;
        this.color = config.color;
        this.opacity = config.opacity;
        this.driftX = (Math.random() - 0.5) * 0.03;
        this.driftY = (Math.random() - 0.5) * 0.02;
        this.pulseSpeed = 0.0005 + Math.random() * 0.0005;
        this.pulseOffset = Math.random() * Math.PI * 2;
        this.time = 0;
      }

      update() {
        this.time += this.pulseSpeed;
        this.x += this.driftX;
        this.y += this.driftY;
      }

      draw() {
        const pulse = 1 + Math.sin(this.time + this.pulseOffset) * 0.1;
        const currentSize = this.size * pulse;

        const grad = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, currentSize
        );

        if (this.color === 'oxblood') {
          grad.addColorStop(0, `rgba(114, 47, 55, ${this.opacity})`);
          grad.addColorStop(0.5, `rgba(114, 47, 55, ${this.opacity * 0.3})`);
          grad.addColorStop(1, 'transparent');
        } else if (this.color === 'sand') {
          grad.addColorStop(0, `rgba(245, 240, 232, ${this.opacity})`);
          grad.addColorStop(0.5, `rgba(232, 224, 212, ${this.opacity * 0.3})`);
          grad.addColorStop(1, 'transparent');
        }

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Minimal geometric accents
    class GeometricAccent {
      constructor() {
        this.elements = [];
        this.generateElements();
      }

      generateElements() {
        // Sparse, intentional placement
        const placements = [
          { x: 0.15, y: 0.2, size: 120, rotation: 15 },
          { x: 0.85, y: 0.3, size: 80, rotation: -20 },
          { x: 0.7, y: 0.75, size: 100, rotation: 45 },
          { x: 0.25, y: 0.8, size: 60, rotation: -10 },
        ];

        placements.forEach(p => {
          this.elements.push({
            x: p.x * width,
            y: p.y * height,
            size: p.size,
            rotation: p.rotation * Math.PI / 180,
            rotSpeed: (Math.random() - 0.5) * 0.00005,
            opacity: 0.03 + Math.random() * 0.03
          });
        });
      }

      draw() {
        this.elements.forEach(el => {
          el.rotation += el.rotSpeed;

          ctx.save();
          ctx.translate(el.x, el.y);
          ctx.rotate(el.rotation);

          // Thin line rectangle - premium minimal
          ctx.strokeStyle = `rgba(245, 240, 232, ${el.opacity})`;
          ctx.lineWidth = 1;
          ctx.strokeRect(-el.size/2, -el.size/2, el.size, el.size);

          ctx.restore();
        });
      }
    }

    // Subtle horizontal lines - suggests data/precision
    class PrecisionLines {
      constructor() {
        this.lines = [];
        for (let i = 0; i < 5; i++) {
          this.lines.push({
            y: 0.2 + (i * 0.15),
            width: 0.1 + Math.random() * 0.3,
            x: Math.random() * 0.6,
            opacity: 0.02 + Math.random() * 0.03,
            drift: (Math.random() - 0.5) * 0.02
          });
        }
      }

      draw() {
        this.lines.forEach(line => {
          line.x += line.drift * 0.01;

          const y = line.y * height;
          const startX = line.x * width;
          const endX = startX + line.width * width;

          const grad = ctx.createLinearGradient(startX, y, endX, y);
          grad.addColorStop(0, 'transparent');
          grad.addColorStop(0.2, `rgba(114, 47, 55, ${line.opacity})`);
          grad.addColorStop(0.8, `rgba(114, 47, 55, ${line.opacity})`);
          grad.addColorStop(1, 'transparent');

          ctx.strokeStyle = grad;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(startX, y);
          ctx.lineTo(endX, y);
          ctx.stroke();
        });
      }
    }

    // Minimal floating particles - dots only
    class MinimalDust {
      constructor() {
        this.particles = [];
        for (let i = 0; i < 25; i++) {
          this.particles.push({
            x: Math.random() * width * 1.2,
            y: Math.random() * height * 1.2,
            size: 1 + Math.random() * 1.5,
            speedX: (Math.random() - 0.5) * 0.1,
            speedY: (Math.random() - 0.5) * 0.08,
            opacity: 0.15 + Math.random() * 0.25
          });
        }
      }

      draw() {
        this.particles.forEach(p => {
          p.x += p.speedX;
          p.y += p.speedY;

          if (p.x < -20) p.x = width + 20;
          if (p.x > width + 20) p.x = -20;
          if (p.y < -20) p.y = height + 20;
          if (p.y > height + 20) p.y = -20;

          ctx.fillStyle = `rgba(212, 201, 184, ${p.opacity})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        });
      }
    }

    // Initialize
    const orbs = [
      new GradientOrb({ x: 0.3, y: 0.4, size: 400, color: 'oxblood', opacity: 0.08 }),
      new GradientOrb({ x: 0.7, y: 0.6, size: 350, color: 'sand', opacity: 0.04 }),
      new GradientOrb({ x: 0.5, y: 0.3, size: 500, color: 'oxblood', opacity: 0.05 }),
      new GradientOrb({ x: 0.2, y: 0.7, size: 300, color: 'sand', opacity: 0.03 }),
    ];

    const geometrics = new GeometricAccent();
    const lines = new PrecisionLines();
    const dust = new MinimalDust();

    // Animation loop
    function animate() {
      // Base - deep charcoal
      ctx.fillStyle = colors.charcoal;
      ctx.fillRect(0, 0, width, height);

      // Subtle texture gradient
      const baseGrad = ctx.createRadialGradient(
        width * 0.5, height * 0.5, 0,
        width * 0.5, height * 0.5, width * 0.8
      );
      baseGrad.addColorStop(0, 'rgba(44, 44, 44, 0.3)');
      baseGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = baseGrad;
      ctx.fillRect(0, 0, width, height);

      // Update camera
      camera.update();

      ctx.save();
      camera.apply();

      // Draw layers
      orbs.forEach(orb => {
        orb.update();
        orb.draw();
      });

      geometrics.draw();
      lines.draw();
      dust.draw();

      ctx.restore();

      // Vignette - premium cinematic
      const vignette = ctx.createRadialGradient(
        width/2, height/2, height * 0.25,
        width/2, height/2, height * 0.95
      );
      vignette.addColorStop(0, 'transparent');
      vignette.addColorStop(0.7, 'rgba(0, 0, 0, 0.2)');
      vignette.addColorStop(1, 'rgba(0, 0, 0, 0.6)');
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, width, height);

      // Subtle film grain
      if (Math.random() > 0.97) {
        ctx.fillStyle = `rgba(245, 240, 232, ${Math.random() * 0.02})`;
        ctx.fillRect(
          Math.random() * width,
          Math.random() * height,
          Math.random() * 2,
          Math.random() * 2
        );
      }

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
