<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Constellation - Nuclear Energy Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1A1A1A;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        #canvas-container {
            width: 100%;
            height: 100vh;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <script>
        // Constellation Nuclear Energy - Atomic orbital visualization
        // Brand colors: Blue/Cyan energy theme

        const NUCLEAR_BLUE = [100, 180, 255];
        const NUCLEAR_CYAN = [0, 255, 255];
        const NUCLEAR_WHITE = [220, 240, 255];

        let atoms = [];
        let energyWaves = [];
        let particles = [];
        let time = 0;

        class Atom {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.electrons = [];
                this.numOrbits = floor(random(2, 5));
                this.phase = random(TWO_PI);
                this.pulseSpeed = random(0.02, 0.04);

                // Create electron orbits
                for (let i = 0; i < this.numOrbits; i++) {
                    let orbitRadius = this.size * (0.4 + i * 0.25);
                    let numElectrons = floor(random(1, 4));
                    let orbitSpeed = random(0.01, 0.03) * (random() > 0.5 ? 1 : -1);
                    let tilt = random(-0.3, 0.3);

                    for (let j = 0; j < numElectrons; j++) {
                        this.electrons.push({
                            orbitRadius: orbitRadius,
                            angle: (TWO_PI / numElectrons) * j + random(-0.2, 0.2),
                            speed: orbitSpeed,
                            tilt: tilt,
                            size: random(2, 4)
                        });
                    }
                }
            }

            update() {
                this.phase += this.pulseSpeed;
                for (let e of this.electrons) {
                    e.angle += e.speed;
                }
            }

            draw() {
                push();
                translate(this.x, this.y);

                // Draw orbital paths
                noFill();
                for (let i = 0; i < this.numOrbits; i++) {
                    let orbitRadius = this.size * (0.4 + i * 0.25);
                    stroke(NUCLEAR_BLUE[0], NUCLEAR_BLUE[1], NUCLEAR_BLUE[2], 30);
                    strokeWeight(0.5);
                    ellipse(0, 0, orbitRadius * 2, orbitRadius * 2 * 0.3);
                }

                // Draw nucleus with glow
                noStroke();
                let nucleusSize = this.size * 0.15 + sin(this.phase) * 2;

                // Outer glow
                for (let s = nucleusSize * 4; s > 0; s -= 3) {
                    let alpha = map(s, 0, nucleusSize * 4, 150, 5);
                    fill(NUCLEAR_CYAN[0], NUCLEAR_CYAN[1], NUCLEAR_CYAN[2], alpha);
                    ellipse(0, 0, s, s);
                }

                // Core
                fill(NUCLEAR_WHITE[0], NUCLEAR_WHITE[1], NUCLEAR_WHITE[2]);
                ellipse(0, 0, nucleusSize, nucleusSize);

                // Draw electrons
                for (let e of this.electrons) {
                    let ex = cos(e.angle) * e.orbitRadius;
                    let ey = sin(e.angle) * e.orbitRadius * 0.3 + sin(e.angle) * e.tilt * 20;

                    // Electron glow
                    for (let s = e.size * 3; s > 0; s -= 1) {
                        let alpha = map(s, 0, e.size * 3, 200, 20);
                        fill(NUCLEAR_BLUE[0], NUCLEAR_BLUE[1], NUCLEAR_BLUE[2], alpha);
                        ellipse(ex, ey, s, s);
                    }

                    // Electron core
                    fill(NUCLEAR_WHITE[0], NUCLEAR_WHITE[1], NUCLEAR_WHITE[2]);
                    ellipse(ex, ey, e.size * 0.5, e.size * 0.5);
                }

                pop();
            }
        }

        class EnergyWave {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = random(200, 400);
                this.speed = random(1, 2);
                this.alpha = 255;
            }

            update() {
                this.radius += this.speed;
                this.alpha = map(this.radius, 0, this.maxRadius, 100, 0);
                return this.radius < this.maxRadius;
            }

            draw() {
                noFill();
                stroke(NUCLEAR_CYAN[0], NUCLEAR_CYAN[1], NUCLEAR_CYAN[2], this.alpha);
                strokeWeight(1);
                ellipse(this.x, this.y, this.radius * 2, this.radius * 2);
            }
        }

        class EnergyParticle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = random(width);
                this.y = random(height);
                this.vx = random(-0.3, 0.3);
                this.vy = random(-0.3, 0.3);
                this.size = random(1, 3);
                this.alpha = random(50, 150);
                this.life = random(100, 300);
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;

                if (this.life <= 0 || this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                    this.reset();
                }
            }

            draw() {
                noStroke();
                let fadeAlpha = this.alpha * min(1, this.life / 30);
                fill(NUCLEAR_BLUE[0], NUCLEAR_BLUE[1], NUCLEAR_BLUE[2], fadeAlpha);
                ellipse(this.x, this.y, this.size, this.size);
            }
        }

        function setup() {
            let canvas = createCanvas(windowWidth, windowHeight);
            canvas.parent('canvas-container');

            // Create atoms
            let numAtoms = floor(width * height / 150000) + 3;
            for (let i = 0; i < numAtoms; i++) {
                atoms.push(new Atom(
                    random(100, width - 100),
                    random(100, height - 100),
                    random(80, 150)
                ));
            }

            // Create background particles
            for (let i = 0; i < 100; i++) {
                particles.push(new EnergyParticle());
            }
        }

        function draw() {
            // Dark background with fade
            background(26, 26, 26, 30);

            time += 0.01;

            // Draw and update background particles
            for (let p of particles) {
                p.update();
                p.draw();
            }

            // Occasionally create energy waves
            if (frameCount % 90 === 0 && atoms.length > 0) {
                let atom = random(atoms);
                energyWaves.push(new EnergyWave(atom.x, atom.y));
            }

            // Update and draw energy waves
            for (let i = energyWaves.length - 1; i >= 0; i--) {
                energyWaves[i].draw();
                if (!energyWaves[i].update()) {
                    energyWaves.splice(i, 1);
                }
            }

            // Draw connections between nearby atoms
            for (let i = 0; i < atoms.length; i++) {
                for (let j = i + 1; j < atoms.length; j++) {
                    let d = dist(atoms[i].x, atoms[i].y, atoms[j].x, atoms[j].y);
                    if (d < 300) {
                        let alpha = map(d, 0, 300, 40, 0);
                        stroke(NUCLEAR_BLUE[0], NUCLEAR_BLUE[1], NUCLEAR_BLUE[2], alpha);
                        strokeWeight(0.5);

                        // Draw dashed energy line
                        let steps = floor(d / 10);
                        for (let s = 0; s < steps; s += 2) {
                            let t1 = s / steps;
                            let t2 = (s + 1) / steps;
                            let x1 = lerp(atoms[i].x, atoms[j].x, t1);
                            let y1 = lerp(atoms[i].y, atoms[j].y, t1);
                            let x2 = lerp(atoms[i].x, atoms[j].x, t2);
                            let y2 = lerp(atoms[i].y, atoms[j].y, t2);
                            line(x1, y1, x2, y2);
                        }
                    }
                }
            }

            // Update and draw atoms
            for (let atom of atoms) {
                atom.update();
                atom.draw();
            }

            // Add subtle scanning grid effect
            stroke(NUCLEAR_BLUE[0], NUCLEAR_BLUE[1], NUCLEAR_BLUE[2], 10);
            strokeWeight(0.5);
            let gridSize = 50;
            for (let x = 0; x < width; x += gridSize) {
                line(x, 0, x, height);
            }
            for (let y = 0; y < height; y += gridSize) {
                line(0, y, width, y);
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>
